/****************************************************/
/* File: tiny.y                                     */
/* The TINY Yacc/Bison specification file           */
/* Compiler Construction: Principles and Practice   */
/* Kenneth C. Louden                                */
/****************************************************/
%{
#define YYPARSER /* distinguishes Yacc output from other code files */

#include "globals.h"
#include "util.h"
#include "scan.h"
#include "parse.h"

#define YYSTYPE TreeNode *
static char * savedName; /* for use in assignments */
static int savedLineNo;  /* ditto */
static TreeNode * savedTree; /* stores syntax tree for later return */
static int yylex(void); // added 11/2/11 to ensure no conflict with lex
static int saveNum;
static int saveType;
%}

%token IF ELSE INT RETURN VOID WHILE
%token ID NUM 
%token ASSIGN EQ LT PLUS MINUS TIMES OVER LPAREN RPAREN SEMI NE LE GT GE LBRACE RBRACE LCURLY RCURLY COMMA
%token ERROR 

%% /* Grammar for TINY */

program     : decl_list
				{ savedTree = $1;}
            ;
decl_list	: decl_list decl
				{   YYSTYPE t = $1;
					if(t!=NULL)
					{ while(t->sibling!=NULL)
						t=t->sibling;
						t->sibling = $2;
						$$ = $1;}
					else $$ = $2;
				}
			| decl
				{
					$$=$1;
				}
			;
decl		: var_decl
				{
					$$=$1;
				}
			| func_decl
				{
					$$=$1;
				}
			;
var_decl	: type_spec save_name SEMI
				{
					$$=$1;
					$$->attr.name = copyString(tokenString);
				}
			| type_spec save_name LBRACE save_num RBRACE SEMI
				{
					$$=$1;
					$$->attr.arr.name = copyString(tokenString);
					$$->attr.type = Array;
					$$->attr.arr.size = atoi(tokenString);
				}
			;
type_spec	: INT
				{
					$$ = newTypeNode(TypeNameK);
					$$->attr.type = INT;
					saveType = INT;
				}
			| VOID
				{
					$$ = newTypeNode(TypeNameK);
					$$->attr.type = VOID;
					saveType = VOID;
				}
			;
func_decl	: type_spec save_name 				{
					$$ = newDeclNode(FuncK);
					$$->attr.name = savedName;
					$$->lineno = lineno;	
			  }
				LPAREN params RPAREN comp_stmt
			  {
				$$ = $3;
				$$->child[0] = $1;
				$$->child[1] = $5;
				$$->child[2] = $7;
			  }

			;
save_name	: ID
				{savedName = copyString(tokenString);
				savedLineNo = lineno;
				}
			;
save_num	: NUM
				{saveNum = atoi(tokenString);
				savedLineNo = lineno;
				}
			;
params		: param_list
				{
					$$ = $1;
				}
			| VOID
				{
					$$ = newDeclNode(ParamK);
					$$->type = Void;
				}
			;
param_list	: param_list COMMA param
				{
				   YYSTYPE t = $1;
				   if (t != NULL)
				   { while(t->sibling != NULL)
						 t = t->sibling;
					t->sibling = $3;
					$$ = $1;}
				   else $$ = $3;
				}
			| param
				{
					$$ = $1;
				}
			;
param		: type_spec save_name
				{
					$$ = $1;
					$$->kind.decl = ParamK;
					$$->attr.name = copyString(tokenString);
				}
			| type_spec save_name LBRACE RBRACE
				{
					$$ = $1;
					$$->kind.decl = ParamK;
					$$->attr.name = copyString(tokenString);
					$$->type = Array;
					$$->size = -1;}
			;
comp_stmt	: LCURLY local_decl stmt_list RCURLY
				{
					$$ = newStmtNode(CompK);
					$$->child[0] = $2;
					$$->child[1] = $3;
				}
			;
local_decl 	: local_decl var_decl
				{  YYSTYPE t = $1;
				   if (t != NULL)
				   { while(t->sibling != NULL)
						 t = t->sibling;
					t->sibling = $2;
					$$ = $1;}
				   else $$ = $2;
				}
			|
				{
					$$ = NULL;
				}
			;
stmt_list	: stmt_list stmt
				{  YYSTYPE t = $1;
					if(t != NULL)
					{ while(t->sibling != NULL)
							t = t->sibling;
						t->sibling = $2;
						$$ = $1;}
					else $$ = $2;
				}
			|
				{
					$$=NULL;
				}
			;
stmt        : exp_stmt { $$ = $1; }
            | comp_stmt { $$ = $1; }
            | select_stmt { $$ = $1; }
            | iter_stmt { $$ = $1; }
            | ret_stmt { $$ = $1; }
            ;
exp_stmt	: exp SEMI
				{
					$$ = $1;
				}
			| SEMI
				{$$=NULL;}
			;
select_stmt	: IF LPAREN exp RPAREN stmt
                 { $$ = newStmtNode(IfK);
                   $$->child[0] = $3;
                   $$->child[1] = $5;
                 }
            | IF LPAREN exp RPAREN stmt ELSE stmt
                 { $$ = newStmtNode(IfK);
                   $$->child[0] = $3;
                   $$->child[1] = $5;
                   $$->child[2] = $7;
                 }
            ;
iter_stmt	: WHILE LPAREN exp RPAREN stmt
				{
					$$ = newStmtNode(IterK);
					$$->child[0] = $3;
					$$->child[1] = $5;
				}
			;
ret_stmt	: RETURN SEMI
				{
					$$ = newStmtNode(RetK);
				}
			| RETURN exp SEMI
				{
					$$ = newStmtNode(RetK);
					$$->child[0] = $2;
				}
			;
exp         : var ASSIGN exp
				{
					$$ = newExpNode(AssignK);
					$$->attr.op = ASSIGN;
					$$->child[0] = $1;
					$$->child[1] = $3;
				}
            | simple_exp { $$ = $1; }
            ;
var			: ID
				{
					$$ = newExpNode(IdK);
					$$->attr.name = copyString(tokenString);
				}
			| ID LBRACE exp RBRACE
				{
					$$ = newExpNode(IdK);
					$$->attr.name = copyString(tokenString);
					$$->child[0] = $3;
					$$->child[0]->kind.exp = ArrK;
				}
			;
simple_exp	: addi_exp relop addi_exp
				{
					$$ = $2;
					$$->child[0] = $1;
					$$->child[1] = $3;
				}
			| addi_exp
				{
					$$ = $1;
				}
			;
relop		: LE {$$ = newExpNode(OpK); $$->attr.op = LE;}
			| EQ {$$ = newExpNode(OpK); $$->attr.op = EQ;}
			| NE {$$ = newExpNode(OpK); $$->attr.op = NE;}
			| LT {$$ = newExpNode(OpK); $$->attr.op = LT;}
			| GT {$$ = newExpNode(OpK); $$->attr.op = GT;}
			| GE {$$ = newExpNode(OpK); $$->attr.op = GE;}
			;
addi_exp	: addi_exp addop term
				{
					$$ = $2;
					$$->child[0] = $1;
					$$->child[1] = $3;
				}
			| term
				{
					$$ = $1;
				}
			;
addop		: PLUS {$$ = newExpNode(OpK); $$->attr.op = PLUS;}
			| MINUS{$$ = newExpNode(OpK); $$->attr.op = MINUS;}
			;
term		: term mulop factor
				{
					$$ = $2;
					$$->child[0] = $1;
					$$->child[1] = $3;
				}
			| factor
				{
					$$ = $1;
				}
			;
mulop		: TIMES {$$ = newExpNode(OpK); $$->attr.op = TIMES;}
			| OVER  {$$ = newExpNode(OpK); $$->attr.op = OVER;}
			;
factor		: LPAREN exp RPAREN
				{
					$$ = $2;
				}
			| var
				{
					$$ = $1;
				}
			| call
				{
					$$ = $1;
				}
			| NUM
				{
					$$ = newExpNode(ConstK);
					$$->attr.val = atoi(numString);
				}
			;
call		: save_name LPAREN args RPAREN
				{
					$$ = newExpNode(CalK);
					$$->attr.name = copyString(tokenString);
					$$->child[0] = $3;
				}
			;
args		: args_list
				{
					$$ = $1;
				}
			|
				{}
			;
args_list	: args_list COMMA exp
				
				{ YYSTYPE t = $1;
				  if(t!=NULL)
				  { while (t->sibling != NULL)
						  t = t->sibling;
					t->sibling = $3;
					$$ = $1;}
				  else $$ = $3;
				}
			| exp
				{ $$ = $1; }
			;
%%

int yyerror(char * message)
{ fprintf(listing,"Syntax error at line %d: %s\n",lineno,message);
  fprintf(listing,"Current token: ");
  printToken(yychar,tokenString);
  Error = TRUE;
  return 0;
}

/* yylex calls getToken to make Yacc/Bison output
 * compatible with ealier versions of the TINY scanner
 */
static int yylex(void)
{ return getToken(); }

TreeNode * parse(void)
{ yyparse();
  return savedTree;
}

